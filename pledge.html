<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Pledge Maze Demo</title>
<style>
canvas { background: #111; display:block; margin:auto; }
</style>
</head>
<body>

<canvas id="c" width="600" height="600"></canvas>

<script>
const W = 21, H = 21; 
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");
const cellSize = canvas.width / W;

const DIR = [
  {x:0,y:-1}, //N
  {x:1,y:0},  //E
  {x:0,y:1},  //S
  {x:-1,y:0}  //W
];
function turnRight(d){return (d+1)%4;}
function turnLeft(d){return (d+3)%4;}

let maze = Array.from({length:H},()=>Array.from({length:W},()=>({wall:[1,1,1,1],vis:false})));

function carve(x,y){
  maze[y][x].vis=true;
  let dirs=[0,1,2,3].sort(()=>Math.random()*2-1);
  for(let d of dirs){
    let nx=x+DIR[d].x, ny=y+DIR[d].y;
    if(nx>=0&&ny>=0&&nx<W&&ny<H&&!maze[ny][nx].vis){
      maze[y][x].wall[d]=0;
      maze[ny][nx].wall[(d+2)%4]=0;
      carve(nx,ny);
    }
  }
}
carve((Math.random()*W)|0,(Math.random()*H)|0);

// random 0–9 wall breaks
let breaks = (Math.random()*10)|0;
for(let i=0;i<breaks;i++){
  let x = (Math.random()*W)|0, y=(Math.random()*H)|0, d=(Math.random()*4)|0;
  let nx=x+DIR[d].x, ny=y+DIR[d].y;
  if(nx>=0&&ny>=0&&nx<W&&ny<H){
    maze[y][x].wall[d]=0;
    maze[ny][nx].wall[(d+2)%4]=0;
  }
}

// players
const starts = [
  {x:0,y:0},             // UL
  {x:W-1,y:0},           // UR
  {x:W-1,y:H-1},         // LR
  {x:0,y:H-1}            // LL
];
const colors = ["red","green","blue","yellow"]; //反時計回り
let players = starts.map((s,i)=>({
  x:s.x, y:s.y, dir:1, pledge:0,
  order:[0,1,2,3], // corner order UL→UR→LR→LL (counterclockwise)
  goalIndex: (i+1)%4 // next goal is clockwise relative to self
}));

function atCorner(p,cornerIdx){
  return p.x === starts[cornerIdx].x && p.y === starts[cornerIdx].y;
}

function stepPlayer(p,i){
  let g = p.order[p.goalIndex];
  // reached target
  if(atCorner(p,g)){
    p.goalIndex = (p.goalIndex+1)%4; // move to next corner
  }

  // if finished full loop and returned to own start, stop
  if(atCorner(p,i) && p.goalIndex === ((i+1)%4)) {
    return; // finished
  }

  // Pledge right-hand
  function can(d){
    let nx=p.x+DIR[d].x, ny=p.y+DIR[d].y;
    if(nx<0||ny<0||nx>=W||ny>=H) return false;
    return maze[p.y][p.x].wall[d]===0;
  }

  // face goal direction bias
  let gx = starts[g].x, gy=starts[g].y;
  let best=0,dxSign=Math.sign(gx-p.x),dySign=Math.sign(gy-p.y);
  if(Math.abs(gx-p.x)>Math.abs(gy-p.y)) best = dxSign>0?1:3;
  else best = dySign>0?2:0;
  p.dir=best;

  // pledge routine
  let r=turnRight(p.dir)
  if(p.pledge===0 && can(r)){
    p.dir=r;
  } else {
    while(!can(p.dir)) { 
      p.dir = turnLeft(p.dir);
      p.pledge++;
    }
    p.pledge--;
  }

  p.x += DIR[p.dir].x;
  p.y += DIR[p.dir].y;
}

function draw(){
  ctx.clearRect(0,0,600,600);
  ctx.strokeStyle="#888";
  for(let y=0;y<H;y++){
    for(let x=0;x<W;x++){
      let c=maze[y][x];
      if(c.wall[0]){ctx.beginPath();ctx.moveTo(x*cellSize,y*cellSize);ctx.lineTo((x+1)*cellSize,y*cellSize);ctx.stroke();}
      if(c.wall[1]){ctx.beginPath();ctx.moveTo((x+1)*cellSize,y*cellSize);ctx.lineTo((x+1)*cellSize,(y+1)*cellSize);ctx.stroke();}
      if(c.wall[2]){ctx.beginPath();ctx.moveTo((x+1)*cellSize,(y+1)*cellSize);ctx.lineTo(x*cellSize,(y+1)*cellSize);ctx.stroke();}
      if(c.wall[3]){ctx.beginPath();ctx.moveTo(x*cellSize,(y+1)*cellSize);ctx.lineTo(x*cellSize,y*cellSize);ctx.stroke();}
    }
  }

  players.forEach((p,i)=>{
    ctx.fillStyle=colors[i];
    ctx.beginPath();
    ctx.arc(
      (p.x+0.5)*cellSize,
      (p.y+0.5)*cellSize,
      cellSize*0.35,
      0,Math.PI*2
    );
    ctx.fill();
  });
}

function loop(){
  players.forEach((p,i)=>stepPlayer(p,i));
  draw();
  requestAnimationFrame(loop);
}
draw();
loop();
</script>
</body>
</html>
